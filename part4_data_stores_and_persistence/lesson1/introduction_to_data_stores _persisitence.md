# Introduction to Data Stores and Persistence
Decisions about Data design can affect your whole application! In this course, you'll learn about the different layers in these types of applications and how they apply to Data Stores and Persistence.


![Presentation, Application, and Data Layers](https://video.udacity-data.com/topher/2020/March/5e73dfed_/.png)

# Evolution of Data Storage
![Data Stores & Persistence: A Timeline](https://github.com/iamAkolab/udacity_javadev_nanodegree/assets/77028341/11d8b12a-0a04-49ef-87af-8bac1f8abf03)

## A Short Timeline of Persistence
* 1970: Relational Databases
* 1986: SQL becomes ANSI Standard
* 2001: Hibernate 1.0
* 2006: Java Persistence API 1.0
* 2009: JPA 2.0
* 2010: Hibernate 3.0 conforms to JPA Specification
* Today!: Hibernate 5.4.x and Jakarta Persistence 2.2

# Final Project: Critter Chronologer
For the final project in this course, we’ll be creating the Critter Chronologer, a software as a service application that provides a scheduling interface for small businesses that take care of animals. We’ll allow users to create schedules that associate pets, owners, and employees for a pet-care event on a specified date.

This application will store all the relevant data in a MySQL Database and allow a predefined controller layer to send and receive updates. You’ll have to design all the data objects on the back end and create the data and service layers to update and retrieve them.

![Any Time Now…](https://github.com/iamAkolab/udacity_javadev_nanodegree/assets/77028341/767515bb-8b01-43df-b801-b4d908138dc9)
